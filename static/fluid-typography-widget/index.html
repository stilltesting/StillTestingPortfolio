<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="stylesheet" type="text/css" href="./style/style.css">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,500,0,0" />

	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

	<style>
	    :root {
	      --chapter-scale: 3;
	      --subsection-scale: 2;
	      --root-font-size: 18px;
	    }

	    h2.chapter {
	    	font-size: var(--chapter-scale);
	    }

	    h3.subsection {
	    	font-size: var(--subsection-scale);
	    }

	    h4 {
	    	font-size: var(--h3-scale);
	    }

	    body {
	    	font-size: var(--root-font-size);
	    }
	</style>

	<title>Fluid Typography Structure Widget</title>
</head>
<body>
<div id="buttons">
	<button id="parametersToggle" class="open">
		<span class="material-symbols-outlined">tune</span>
	</button>
	<button id="chartsToggle" class="closed">
		<span class="material-symbols-outlined">monitoring</span>
	</button>
</div>

<div id="controls">
	<div id="parameters" class="show">
		<h2 class="UI-text">Parameters</h2>
		<div class="block">
			<h3 class="UI-text">Font Size Scaling</h3>

			<label for="minRes">Minimal resolution [px]:</label><br>
			<input type="number" id="minRes" name="minRes" value="480" step="120" onchange="updateCSS()"><br>

			<label for="maxRes">Maximal resolution [px]:</label><br>
			<input type="number" id="maxRes" name="maxRes" value="1920" step="120" onchange="updateCSS()"><br>

			<label for="minFontSize">Minimal font size [px]:</label><br>
			<input type="number" id="minFontSize" name="minFontSize" value="18" step="1" onchange="updateCSS()"><br>

			<label for="maxFontSize">Maximal font size [px]:</label><br>
			<input type="number" id="maxFontSize" name="maxFontSize" value="22" step="1" onchange="updateCSS()"><br>
		</div>

		<div class="block">
			<h3 class="UI-text">Leading</h3>
			
			<label for="minLeading">Minimal leading [em]:</label><br>
			<input type="number" id="minLeading" name="minLeading" value="1.4" step="0.1" onchange="updateCSS()"><br>

			<label for="maxLeading">Maximal leading [em]:</label><br>
			<input type="number" id="maxLeading" name="maxLeading" value="1.8" step="0.1" onchange="updateCSS()"><br>
		</div>

		<div class="block">
			<h3 class="UI-text">Hierarchy Scaling</h3>
					
			<label for="minChapterScale">H1 Minimal Scale Factor:</label><br>
			<input type="number" id="minChapterScale" name="minChapterScale" value="3" step="0.5" onchange="updateCSS()"><br>

			<label for="maxChapterScale">H1 Maximal Scale Factor:</label><br>
			<input type="number" id="maxChapterScale" name="maxChapterScale" value="5" step="0.5" onchange="updateCSS()"><br>

			<label for="minSubsectionScale">H2 Minimal Scale Factor:</label><br>
			<input type="number" id="minSubsectionScale" name="minSubsectionScale" value="1.2" step="0.1" onchange="updateCSS()"><br>

			<label for="maxSubsectionScale">H2 Maximal Scale Factor:</label><br>
			<input type="number" id="maxSubsectionScale" name="maxSubsectionScale" value="1.5" step="0.1" onchange="updateCSS()"><br>

			<label for="minH3Scale">H3 Minimal Scale Factor:</label><br>
			<input type="number" id="minH3Scale" name="minH3Scale" value="1" step="0.1" onchange="updateCSS()"><br>

			<label for="maxH3Scale">H3 Maximal Scale Factor:</label><br>
			<input type="number" id="maxH3Scale" name="maxH3Scalee" value="1" step="0.1" onchange="updateCSS()"><br>
		</div>

		<div style="clear:both"></div>

		<button onclick="updateCSS()" id="updateCSS">Update CSS</button>

	</div>

	<div id="charts" class="hide">
		<h2 class="UI-text">Charts</h2>
		<h3 class="UI-text">Font Size Progression</h3>
		<canvas id="fontSizeChart"></canvas>

		<h3 class="UI-text">Leading Progression</h3>
		<canvas id="leadingChart"></canvas>

		<h3 class="UI-text">Hierarchy Relative Progression</h3>
		<canvas id="hierarchyChart"></canvas>
	</div>
</div>

<div id="contentWrapper" lang="cs">
	<div id="textBox">
		<h2 class="chapter">Úvod</h2>
		
		<p>
			Kniha má v&nbsp;sociokulturním prostoru výsadní postavení jako intelektuální, estetický i&nbsp;společenský artefakt. S&nbsp;konceptem knihy je neoddělitelně spjata značná část historie a&nbsp;vývoje typografie a&nbsp;grafického designu. Nástup digitalizace a&nbsp;rozšíření výpočetních technologií je spjatý též s&nbsp;rozšířením čtení v&nbsp;elektronické podobě a&nbsp;vznikem takzvané elektronické knihy (též e-knihy). Proces jejího utváření však stále není dovršen, ať už z&nbsp;hlediska společenského a&nbsp;kulturního vnímání či grafického designu a&nbsp;typografie. Elektronická kniha je tak stále vnímána jako jakási podružná alternativa ke knize tištěné. Design elektronických knih je zpravidla chudý až neexistující, sklouzává k&nbsp;uniformitě a&nbsp;individuální tvář e-knihy se omezuje pouze na pomyslnou obálku. Čestné výjimky ve formě autorských či uměleckých e-knih, které tvoří rovnocennou alternativu tištěných knih a&nbsp;působí jako svébytné artefakty, často stojí mimo hlavní proud zájmu čtenářů. Jejich výtvarná pojetí jsou odvážná, experimentální a&nbsp;nezařaditelná do běžné produkce, podobně jako různá bibliofilská vydání, jaká známe z&nbsp;prostředí tištěných knih. Spojujícím prvkem takto vypravených knih je paradoxně jejich diverzita&nbsp;— oproti běžné produkci využívají celou škálu individuálních výtvarných i&nbsp;typografických přístupů, které prakticky nelze uplatnit v&nbsp;širším kontextu. Na jedné straně tedy máme grafickou úpravu takřka neznatelnou, na druhé straně nesmírně bohatou až přebujelou. Pomyslná střední cesta běžné knižní produkce v&nbsp;digitálním prostoru takřka neexistuje.
		</p>

		<p>
			Kniha je velmi komplexní pojem, se kterým je spjato obrovské množství otázek spojených s&nbsp;její kulturní, společenskou i&nbsp;estetickou funkcí a&nbsp;s&nbsp;technologickou stránkou její produkce, její materialitou, její uživatelskou zkušeností a&nbsp;mnoha dalšími aspekty. Jako kterýkoliv jiný komplexní pojem tvoří i&nbsp;kniha síť vzájemně provázaných vhledů. Proto, je-li řeč o&nbsp;knižním designu, grafické úpravě a&nbsp;typografii, nelze opomenout ani tato další hlediska. Spektrum použité a&nbsp;studované literatury je tak odpovídajícím způsobem široké a&nbsp;pokrývá značnou škálu oborů, které se knihou zabývají z&nbsp;různých úhlů pohledu.
		</p>

		<p>
			Benjamin Bratton (2016) ve své knize a&nbsp;zároveň manifestu stejnojmenného programu institutu Strelka The New Normal tvrdí, že k&nbsp;popisu nových jevů často jsou často používány kombinace starých, zaužívaných pojmů. Toto označování nového starým pak podle Brattona vede k&nbsp;určitému omezení rozhledu a&nbsp;umělému limitování potenciálu nových technologií. Jako příklad uvádí v&nbsp;prvopočátcích vynálezu moderních automobilů často užívaný pojem kočár bez koní (horseless carriage), který při návrhu nových vozidel naváděl k&nbsp;používání designového jazyka spjatého s&nbsp;klasickým koňským spřežením, a&nbsp;to včetně připodobnění sedadla řidiče posedu pro kočího (Bratton 2016)&nbsp;— podobně mluví též Drucker (2003). Emancipačním momentem vynálezu se stalo až opuštění této představy, přizpůsobení vozidel potřebám řidiče a&nbsp;cestujících&nbsp;— vstup designu&nbsp;— a&nbsp;vznik pojmu automobil. Podobnou situaci je dnes stále možné sledovat na poli elektronických knih. Ty&nbsp;se staly natolik všudypřítomnými a&nbsp;dosáhly takové sociokulturní penetrace, že s naprostou samozřejmostí vstupují do našich životů skrze displeje našich telefonů a počítačů. Málokoho tak napadne zpochybňovat jejich formu, styl i&nbsp;charakter. Staly se jakýmsi substitutem té pravé tištěné knihy s&nbsp;obecně přijímanými, nezpochybňovanými a&nbsp;v&nbsp;důsledku takřka neviditelnými nedostatky. Elektronické knihy jsou tak stále vztahovány a kontrastovány se svým tištěným předobrazem a&nbsp;stávají se v&nbsp;podstatě jeho pokřiveným digitálním zrcadlem, jakýmsi nedokonalým odrazem (Velagić 2014; Kovač 2019). V&nbsp;souladu s&nbsp;tím je možné pozorovat jakousi efemérnost digitální typografie (Bath 2012),&nbsp;ta se pak stává pouhým utilitárním nástrojem k&nbsp;předání informace. Tento pocit efemérnosti se tranzitivně přenáší na celou elektronickou knihu&nbsp;— po přečtení se ztrácí kdesi v&nbsp;digitálním prostoru, kde&nbsp;— dále neviditelná&nbsp;— neplní, ani nemůže plnit svou reprezentační a&nbsp;společenskou funkci (Gruningová 2018).
		</p>

		<h3 class="subsection">Definice pojmů</h3>

		<p>
			Práce operuje s některými pojmy, které je třeba nejprve definovat a vysvětlit, aby bylo jasně srozumitelné, co je nimi v textu myšleno. Definicemi je zároveň vymezen okruh zájmu práce, na nějž navazují i její jednotlivé cíle.
		</p>

		<h4>Tiskové a digitální prostředí</h4>

		<p>
			Pojmy tiskové a digitální prostředí představují ústřední opoziční dvojici této práce. Ačkoliv se pod oba pojmy dá zahrnout celé spektrum různých obsahů, práce se vzhledem ke svému tématu zaměří hlavně na textový obsah.
		</p>

		<p>
			Tiskové prostředí tedy práce chápe jako všechny textové dokumenty, jejichž primárním způsobem rozšíření je distribuce v tištěné formě.  V důsledku jsou tak vytvářeny fyzické artefakty, mezi než jsou zahrnuty především knihy, časopisy, noviny a mnohé další formy tištěného textu.
		</p>

		<p>
			Digitálním prostředím je pro účely této práce naopak myšlen veškerý textový obsah šířený primárně v elektronické formě v některém z dostupných formátů — zahrnout můžeme webové stránky, různé typy textových dokumenty, elektronické knihy a mnohé další.
		</p>

		<p>
			Přechod mezi oběma prostředími je samozřejmě možný. Obsah lze transformovat z tištěné verze do digitálního prostředí například skenováním či nafocením, a naopak z elektronické verze do tiskového prostředí pochopitelně tiskem. Výsledkem obou procesů jsou ale často verze dokumentů, které kvalitativně zaostávají za těmi, které jsou pro dané prostředí přímo určeny, a tedy i adekvátně připraveny.
		</p>

		<h4>Post-tiskové prostředí</h4>

		<p>
			Elektronické texty (e-texty) zahrnují celou škálu dokumentů a formátů s velmi rozmanitou mírou integrace do digitálního prostředí. V perspektivě této práce je jedním z důležitých aspektů to, že některé z nich stále odkazují na svůj tiskový původ — mají jasně a přesně specifikovaný formát, bývají neměnné, statické a často podléhají požadavkům tisknutelnosti — Pecina (2017) takové dokumenty označuje jako neměnné definitivní. V topologii elektronických textových dokumentů tak zastávají hraniční místo na pomezí digitálního a tištěného prostoru. Právě pro silnou vazbu na tiskové prostředí a požadavek tisknutelnosti, kterému jsou podřízeny všechny vlastnosti dotyčných dokumentů, zavádím pro tyto hybridní dokumenty kategorii post-tiskového prostředí — tedy kategorii, do níž spadají dokumenty, které se i přes svůj digitální původ stále odkazují k fyzickým, tištěným textům. Příkladem mohou být různé úřední dokumenty, listiny, akademické studie, formuláře a některé elektronické knihy (Alvardo & Pyle 2019). Typickým znakem může být například publikování ve formátu PDF, který se tištěným dokumentům v klíčových parametrech přibližuje. Takové dokumenty je vzhledem k jejich vlastnostem pohodlné číst jen na velmi omezeném množství zařízení. Na zbylé většině je uživatel konfrontován s dokumentem, který v nějakém směru přesahuje možnosti pohodlného zobrazení celé stránky.
		</p>

		<p>
			Na opačném konci spektra stojí naopak dokumenty — nazývejme je dokumenty dokonale dynamickými —, které se od fyzické podoby distancovaly natolik, že z jejich původního vzhledu a grafické úpravy (v tom nejširším smyslu slova) zbývá jen pouhý holý text s vyznačenou typografickou strukturou. Spolu s tím však zavrhují i veškeré grafické a výtvarné možnosti digitálního prostředí. Konkrétní podoby takový text nabývá až v konkrétním zařízení, které čtenář používá. Čtenář může do textu různými způsoby zasahovat, měnit písmo, řádkový proklad, upravovat šířku okrajů, a tím i měnit zážitek ze čtení dle svého uvážení (Pecina 2017). V ideálním případě s poučeným čtenářem lze takový postup považovat za dokonalé naplnění vize takzvané křišťálové číše, kdy je veškerá individualita knihy potlačena do pozadí, aby se pro čtenáře stala neviditelnou, a ten se tak mohl soustředit čistě na obsah (Warde 1956). Dokonalou dynamičností a ztrátou konkrétní pevné formy textu mizí vazba na vlastnosti tištěných dokumentů. A v tomto důsledném odcizení a vzepření tiskovému prostředí lze též spatřovat určité prvky post-tiskového prostředí. Totální odvržení všech vlastností spojených s tištěnými dokumenty je možné svým způsobem považovat za vazbu na tiskové prostředí, a to v tom hledisku, že tento typ dokumentů se usilovně snaží nebýt tím, čím jsou tištěné dokumenty.
		</p>

		<p>
			Definiční prvky kategorie post-tiskového prostředí, jak jej chápe tato práce, jsou tedy:
		</p>

		<ol>
			<li>
				statické dokumenty s pevně danými vlastnostmi, rozměry stránky a layoutem,
			</li>
			<li>
				dokonale dynamické dokumenty, které naopak potírají veškerou individualitu textu, brání se grafické úpravě a jsou vzájemně zaměnitelné — na první pohled je od sebe na stejném zařízení prakticky není možné odlišit.
			</li>
		</ol>

		<p>
			Další dílčí charakteristiky jsou podrobněji rozebrány v části věnované komparativní analýze tiskového a digitálního prostředí.
		</p>

		<h4>Kniha</h4>

		<p>
			Pojem kniha se zdá na první pohled zcela jasným a srozumitelným a v intuitivním chápání tomu tak skutečně je, v odborném diskursu se ale kniha a zejména její definice setkává se značnou problematizací. V prvé řadě je třeba připustit, že kniha není jednoznačný pojem, je možné ji nahlížet z mnoha různých úhlů, jejichž podrobnějšímu rozebrání bude věnována samostatná kapitola. V základní rovině lze knihu chápat knihu dvěma pohledy:
		</p>

		<ol>
			<li>
				V jedné rovině lze pod pojmem kniha rozumět dobře známou tištěnou knihu s konkrétními fyzickými vlastnostmi a parametry, které se dají u každého jednotlivého jednotlivého exempláře poměrně dobře popsat (počet stran, typ vazby, použité tiskové techniky a technologie, barevnost, použité písmo atd.). Tuto představu knihy lze označit pojmem kniha-objekt.
			</li>
			<li>
				V druhé rovině si však lze při poněkud abstraktnějším uvažování pod pojmem kniha představit její obsahovou složku, která může být velmi rozmanitá a může nabývat nepřeberného množství forem od fyzické, tištěné, přes elektronickou či audio formu, až po potenciální, dosud neznámé budoucí formy. V tomto případě je možné používat označení kniha-obsah.
			</li>
		</ol>

		<p>
			Kniha — ve smyslu objektu — prošla mnoha historickými transformacemi a pojem tak v průběhu dějin označoval mnohdy fyzicky zcela odlišné objekty — hliněné tabulky, svitky, různé typy kodexů, a nakonec též nehmotné elektronické knihy (Kovač et al. 2019; Borsuk 2018). Je zřejmé, že definice knihy z roku 1964 podle UNESCO, tedy: „Kniha je neperiodická tištěná publikace o nejméně 49 stranách — počítáno bez obálky — vydaná a zveřejněná v dané zemi,” (UNESCO 1964) je pro dnešní a vlastně i historickou realitu nedostatečná. Definice je úzce svázána s tiskovými technologiemi a fyzickou podobou knihy, která se v evropském kontextu postupně stabilizovala až do 18. století (Borsuková 2018). Klíčovým slovem je zde *tištěná publikace*, jehož použitím jsou vyloučeny jakékoliv formy digitálního obsahu, a to včetně elektronických verzí tištěných knih, ale i knihy ručně psané či reprodukované jinou formou než tiskem. I další snahy o kompaktní a uzavřenou definici selhávají, přestože je kniha „dobře známý, běžný a všudypřítomný objekt“ (Velagić 2014). Důraz na textový obsah vylučuje dětské knihy, některé umělecké a obrazové publikace i komiksy, zaměření na dlouhé imerzivní čtení je naproti tomu silně subjektivní a informační architektura zase nemá zcela jasné projevy napříč médii a v některých dílech nemusí být zastoupena v plném rozsahu (Kovač et al., 2019). Na základě toho Velagić (2014) dokonce tvrdí, že konsenzuální definice knihy neexistuje ani na zcela základní úrovni.
		</p>

		<p>	
			Kovač a kolegové (2019) naproti tomu identifikují čtyři kritéria pro definici knihy: minimální délku, důraz na textový obsah, ohraničenost a příslušnou informační architekturu. Sami autoři však upozorňují, že tyto identifikátory jsou do určité míry subjektivní a přiznávají jim jistý „kvantový element“ (Kovač et al., 2019) — tedy závislost na pozorovateli. Proto si text ani neklade ambici kritéria jakýmkoliv způsobem kvantifikovat.
		</p>

		<p>	
			Morton (2013) uvažuje v kontextu globální klimatické krize takzvané hyperobjekty. Jedná se o jevy tak rozsáhlé a široce distribuované v čase i prostoru, že je žádný jednotlivec nedokáže obsáhnout a prožít v celém jejich rozsahu. Podobně lze uvažovat i nad knihou jako kulturním fenoménem. Naplňuje znaky distribuovanosti jednak na úrovni znalostní — každý jednotlivec v závislosti na svém sociokulturním kontextu dokáže intuitivně identifikovat a nějak, byť nedokonale, definovat knihu, definice se překrývají, ale nejsou totožné— a jednak na úrovni časoprostorového uspořádání — knihy jsou distribuované napříč celou historií lidstva, pravděpodobně jí též přesáhnou, a jsou přítomné téměř všude, kam lidstvo nějakým způsobem zasáhlo. Není proto v silách žádné jednotlivce obsáhnout všechny existující i již neexistující knihy. Knihu tak lze v návaznosti na Mortona označit za kulturní hyperobjekt. Toto uvažování má tu výhodu, že dokáže postihnout i formy knihy, které dosud neexistují, a i ty, které už zanikly. Zároveň je takto možné uvažovat knihy i v xenoracionálních kontextech. Taková definice je zdánlivě příliš široká a vágní, najde ale své uplatnění při zkoumání knihy napříč kulturními hranicemi a historickými epochami a při posuzování jejích proměn v potenciálních budoucnostech.
		</p>

		<p>
			Pro potřeby této práce bude postačovat definice vycházející z vlastností popsaných v předchozích odstavcích. Kniha je zde vnímána jako konečný, primárně lineární textový obsah, který má alespoň základní informační architekturu (minimálně název a strukturování textu) a současně nabývá nějaké (ve vztahu k typu obsahu) minimální délky s důrazem na dlouhé, soustředěné čtení. Nebude-li význam z kontextu patrný a bude třeba zdůraznit fyzický aspekt, bude používán pojem kniha-objekt, fyzická kniha, tištěná kniha či kodexová kniha — pod těmito pojmy bude rozuměn takový objekt, který naplňuje intuitivní sociokulturně dané charakteristiky objektu, jež běžně nazýváme knihou, či je za knihu konsenzuálně označován. Naproti tomu knihou-obsahem bude myšlen takový obsah, který nabývá či může nabývat nějaké libovolné formy knihy.
		</p>

		<h4>Elektronická kniha (e-kniha)</h4>

		<p>
			Jestliže kniha pozbývá konkrétní definice a je nejlépe vnímána skrze konseznuální shodu, přídomkem elektronická se hranice ještě dále rozostřují (Vassiliou & Rowley 2008). Jako elektronická kniha nemusí být označen pouze obsah, který by byl v tradičním pojetí považován za knihu. Ve formátu elektronických knih lze totiž poměrně snadno vydávat i samostatné povídky, reportáže eseje, odborné texty a další krátké útvary, jejichž samostatné publikování by se v tištěné podobě ekonomicky nevyplatilo — odpadají totiž náklady spojené s tiskem a distribucí fyzických objektů. Pod pojmem elektronická kniha tak lze rozumět mnohem širší spektrum možných obsahů než pod zdánlivě obecnějším pojmem kniha. V textu práce bude elektronickou knihou rozuměn jakýkoliv obsah, který je vydán nebo potenciálně může být vydán v některém z formátů elektronických knih. Důraz je ovšem kladen primárně na textový obsah a dlouhé a soustředěné čtení — v kontrastu by například komiksová literatura vyžadovala zcela jiná hlediska a řešení odlišné sady problémů.
		</p>

		<h4>Uživatel a čtenář</h4>

		<p>
			Ačkoliv v kontextu knihy mluvíme dominantně o čtenáři, a nikoliv o uživateli, následující text používá oba pojmy do určité míry zaměnitelně. Důvodem je zejména to, že elektronickou knihu můžeme z perspektivy čtenářství chápat jako zaměnitelnou s běžnou tištěnou knihou — a převládá tedy čtenářská role —, naproti tomu pohledem interakčního a produktového designu ji lze vnímat jako software či jako uživatelské rozhraní (<i>interface</i>) — převládá tak uživatelská role. Práce se snaží specifické významy pojmů respektovat a podle zvoleného slova uživatel či čtenář přikládá pozornost příslušné perspektivě.
		</p>
	</div>
</div>

<script>
	var textBox = document.getElementById("textBox");
	var minRes = document.getElementById("minRes").value;
    var maxRes = document.getElementById("maxRes").value;
    var minFontSize = document.getElementById("minFontSize").value;
    var maxFontSize = document.getElementById("maxFontSize").value;
	
	var minLineHeight = document.getElementById("minLeading").value;
    var maxLineHeight = document.getElementById("maxLeading").value;

    var minChapterScale = document.getElementById("minChapterScale").value;
    var maxChapterScale = document.getElementById("maxChapterScale").value;
    var minSubsectionScale = document.getElementById("minSubsectionScale").value;
    var maxSubsectionScale = document.getElementById("maxSubsectionScale").value;
    var minH3Scale = document.getElementById("minH3Scale").value;
    var maxH3Scale = document.getElementById("maxH3Scale").value;

    var currentTextFontSize = parseFloat(getComputedStyle(textBox).getPropertyValue('font-size'));
    var viewportWidth = document.documentElement.clientWidth;

    var currentLeading = parseFloat(getComputedStyle(textBox).getPropertyValue("line-height")) / currentTextFontSize;
    var maxWidth = parseFloat(getComputedStyle(textBox).getPropertyValue('max-width'));
    
    var chapterFontSize;
    var subsectionFontSize;
    var h3FontSize;



	function onResize() {
		updateLineHeight();
		updateHierarchyScaling();
		updateCharts()
	}

    function updateCSS() {
    	updateRootFontSize();
		updateFontScaling();
    	updateLineHeight();
    	updateHierarchyScaling();
    	updateCharts();
    }

    function updateRootFontSize() {
    	minFontSize = document.getElementById("minFontSize").value;
    	document.documentElement.style.setProperty('--root-font-size', minFontSize);
    }

    function updateFontScaling() {
    	// Reading the inputs
    	minRes = document.getElementById("minRes").value;
    	maxRes = document.getElementById("maxRes").value;
    	minFontSize = document.getElementById("minFontSize").value;
    	maxFontSize = document.getElementById("maxFontSize").value;

    	// Computing fluid font scaling
    	var deltaRes = maxRes - minRes;
    	var deltaFontSize = maxFontSize - minFontSize;

    	var fontSizeExpression = "calc(" + minFontSize + "px + (" + deltaFontSize + " * ((100vw - " + minRes + "px) / " + deltaRes + ")))";

      	// Applying the styles
      	textBox.style.fontSize = "clamp(" + minFontSize + "px, " + fontSizeExpression + ", " + maxFontSize + "px)";
    }

    function updateLineHeight() {
    	minLineHeight = document.getElementById("minLeading").value;
    	maxLineHeight = document.getElementById("maxLeading").value;

    	// Getting required variables
    	var width = parseFloat(getComputedStyle(textBox).getPropertyValue('width'));
    	var maxWidth = parseFloat(getComputedStyle(textBox).getPropertyValue('max-width'));

		// Computing fluid leading
		var deltaLineHeight = maxLineHeight - minLineHeight;

		var lineHeight = maxLineHeight - deltaLineHeight * (maxWidth - width) / (maxWidth - minRes);

		var lineHeightExpression = "clamp(" + minLineHeight + "em, " + lineHeight + "em," + maxLineHeight + "em)";

		textBox.style.lineHeight = lineHeightExpression;
    }

    function updateHierarchyScaling() {
		minChapterScale = document.getElementById("minChapterScale").value;
		maxChapterScale = document.getElementById("maxChapterScale").value;
		minSubsectionScale = document.getElementById("minSubsectionScale").value;
		maxSubsectionScale = document.getElementById("maxSubsectionScale").value;
		minH3Scale = document.getElementById("minH3Scale").value;
    	maxH3Scale = document.getElementById("maxH3Scale").value;

    	var deltaChapterScale = maxChapterScale - minChapterScale;
    	var deltaSubsectionScale = maxSubsectionScale - minSubsectionScale;
    	var deltaH3Scale = maxH3Scale - minH3Scale;
    	var deltaTextFontSize = maxFontSize - minFontSize;
    	currentTextFontSize = parseFloat(getComputedStyle(textBox).getPropertyValue('font-size'));

    	var fontSizeFactor = (maxFontSize - currentTextFontSize) / deltaTextFontSize

    	chapterFontSize = Number(maxChapterScale) - deltaChapterScale * fontSizeFactor;
    	subsectionFontSize = Number(maxSubsectionScale) - deltaSubsectionScale * fontSizeFactor;
    	h3FontSize = Number(maxH3Scale) - deltaH3Scale * fontSizeFactor;

    	var chapterFontSizeExpression = "clamp(" + minChapterScale + "em, " + chapterFontSize + "em," + maxChapterScale + "em)";
    	var subsectionFontSizeExpression = "clamp(" + minSubsectionScale + "em, " + subsectionFontSize + "em," + maxSubsectionScale + "em)";
    	var h3FontSizeExpression = "clamp(" + minH3Scale + "em, " + h3FontSize + "em," + maxH3Scale + "em)";


    	document.documentElement.style.setProperty('--chapter-scale', chapterFontSizeExpression);
    	document.documentElement.style.setProperty('--subsection-scale', subsectionFontSizeExpression);
    	document.documentElement.style.setProperty('--h3-scale', h3FontSizeExpression);
    }

    //Charts config defaults
    Chart.defaults.font.family = "Space Mono";
    Chart.defaults.plugins.legend.display = false;
    Chart.defaults.borderColor = 'rgba(0, 0, 0, 0.3)';
    Chart.defaults.color = '#000';

	var fontSizeChart = new Chart(document.getElementById('fontSizeChart'), {
		type: 'line',
		data: {
			label: ["Font Size Progression"],
			datasets: [{
				data: [{x: 0, y: minFontSize}, {x: minRes, y: minFontSize}, {x: maxRes, y: maxFontSize}, {x: Number(maxRes) + 480, y: maxFontSize}],
				order: 2,
				pointBackgroundColor: "blue",
				pointBorderWidth: 0,
				borderColor: "blue",
				borderWidth: 2
			},
			{
				data: [{x: viewportWidth, y: currentTextFontSize}],
				order: 1,
				pointBackgroundColor: "black",
				borderColor: "black"
			}]
		},
		options: {
			scales: {
				y: {
					beginAtZero: true,
					ticks: {
                   		maxRotation: 35,
                   		minRotation: 35
                	}
				}, 
				x: {
					type: 'linear',
					bounds: "data",
					ticks: {
                   		maxRotation: 35,
                   		minRotation: 35
                	},
					afterBuildTicks: axis => axis.ticks = [0, Number(minRes), Number(maxRes), Math.max(Number(maxRes) + 480, viewportWidth)].map(v => ({ value: v }))
        		}
			},
			animation: {
				duration: 100
			},
			aspectRatio: 1.5
		}
	});

	var leadingChart = new Chart(document.getElementById('leadingChart'), {
		type: 'line',
		data: {
			label: ["Leading Progression"],
			datasets: [{
				data: [{x: 0, y: minLineHeight}, {x: Number(minRes), y: minLineHeight}, {x: Number(maxWidth), y: maxLineHeight}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxLineHeight}],
				order: 2,
				pointBackgroundColor: "blue",
				pointBorderWidth: 0,
				borderColor: "blue",
				borderWidth: 2
			},
			{
				data: [{x: viewportWidth, y: currentLeading}],
				order: 1,
				pointBackgroundColor: "black",
				borderColor: "black"
			}]
		},
		options: {
			scales: {
				y: {
					beginAtZero: true,
					ticks: {
                   		maxRotation: 35,
                   		minRotation: 35
                	}
				}, 
				x: {
					type: 'linear',
					bounds: "data",
					ticks: {
                   		maxRotation: 35,
                   		minRotation: 35
                	},
					afterBuildTicks: axis => axis.ticks = [0, Number(minRes), Number(maxWidth), Number(maxRes), Math.max(Number(maxRes) + 480, viewportWidth)].map(v => ({ value: v })),
        		}
			},
			animation: {
				duration: 100
			},
			aspectRatio: 1.5
		}
	});

	var hierarchyChart = new Chart(document.getElementById('hierarchyChart'), {
		type: 'line',
		data: {
			label: ["Hierarchy Relative Progression"],
			datasets: [{
				data: [{x: 0, y: minChapterScale}, {x: minRes, y: minChapterScale}, {x: maxRes, y: maxChapterScale}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxChapterScale}],
				order: 2,
				pointBackgroundColor: "blue",
				pointBorderWidth: 0,
				borderColor: "blue",
				borderWidth: 2
			},
			{
				data: [{x: 0, y: minSubsectionScale}, {x: minRes, y: minSubsectionScale}, {x: maxRes, y: maxSubsectionScale}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxSubsectionScale}],
				order: 2,
				pointBackgroundColor: "BlueViolet",
				pointBorderWidth: 0,
				borderColor: "BlueViolet",
				borderWidth: 2
			},
			{
				data: [{x: 0, y: minH3Scale}, {x: minRes, y: minH3Scale}, {x: maxRes, y: maxH3Scale}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxH3Scale}],
				order: 2,
				pointBackgroundColor: "CornflowerBlue ",
				pointBorderWidth: 0,
				borderColor: "CornflowerBlue",
				borderWidth: 2
			},
			{
				data: [{x: viewportWidth, y: chapterFontSize}],
				order: 1,
				pointBackgroundColor: "black",
				borderColor: "black"
			},
			{
				data: [{x: viewportWidth, y: subsectionFontSize}],
				order: 1,
				pointBackgroundColor: "black",
				borderColor: "black"
			},
			{
				data: [{x: viewportWidth, y: h3FontSize}],
				order: 1,
				pointBackgroundColor: "black",
				borderColor: "black"
			}]
		},
		options: {
			scales: {
				y: {
					beginAtZero: true,
					ticks: {
                   		maxRotation: 35,
                   		minRotation: 35
                	}
				}, 
				x: {
					type: 'linear',
					bounds: "data",
					ticks: {
                   		maxRotation: 35,
                   		minRotation: 35
                	},
					afterBuildTicks: axis => axis.ticks = [0, Number(minRes), Number(maxRes), Math.max(Number(maxRes) + 480, viewportWidth)].map(v => ({ value: v }))
        		}
			},
			animation: {
				duration: 100
			},
			aspectRatio: 1.5
		}
	});

	function updateCharts() {
		currentTextFontSize = parseFloat(getComputedStyle(textBox).getPropertyValue('font-size'));
	    viewportWidth = document.documentElement.clientWidth;
	    currentLeading = parseFloat(getComputedStyle(textBox).getPropertyValue("line-height")) / currentTextFontSize;
	    maxWidth = parseFloat(getComputedStyle(textBox).getPropertyValue('max-width'));
	    console.log(maxWidth);

    	fontSizeChart.data.datasets[0].data = [{x: 0, y: minFontSize}, {x: minRes, y: minFontSize}, {x: maxRes, y: maxFontSize}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxFontSize}];
    	fontSizeChart.data.datasets[1].data = [{x: viewportWidth, y: currentTextFontSize}];
    	fontSizeChart.update();

    	leadingChart.data.datasets[0].data = [{x: 0, y: minLineHeight}, {x: Number(minRes), y: minLineHeight}, {x: Number(maxWidth), y: maxLineHeight}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxLineHeight}];
    	leadingChart.data.datasets[1].data = [{x: viewportWidth, y: currentLeading}];
    	leadingChart.update();

    	hierarchyChart.data.datasets[0].data = [{x: 0, y: minChapterScale}, {x: minRes, y: minChapterScale}, {x: maxRes, y: maxChapterScale}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxChapterScale}];
    	hierarchyChart.data.datasets[1].data = [{x: 0, y: minSubsectionScale}, {x: minRes, y: minSubsectionScale}, {x: maxRes, y: maxSubsectionScale}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxSubsectionScale}];
    	hierarchyChart.data.datasets[2].data = [{x: 0, y: minH3Scale}, {x: minRes, y: minH3Scale}, {x: maxRes, y: maxH3Scale}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxH3Scale}]
    	hierarchyChart.data.datasets[3].data = [{x: viewportWidth, y: chapterFontSize}];
    	hierarchyChart.data.datasets[4].data = [{x: viewportWidth, y: subsectionFontSize}];
    	hierarchyChart.data.datasets[5].data = [{x: viewportWidth, y: h3FontSize}];
    	hierarchyChart.update();
    };


    document.getElementById("parametersToggle").addEventListener("click", function() {
  		var controls = document.getElementById("controls");
		controls.classList.toggle("show");
		controls.classList.toggle("hide");
		var parametersToggle = document.getElementById("parametersToggle");
		parametersToggle.classList.toggle("open");
		parametersToggle.classList.toggle("closed");
	});

	document.getElementById("chartsToggle").addEventListener("click", function() {
		var charts = document.getElementById("charts");
		charts.classList.toggle("show");
		charts.classList.toggle("hide");
		var chartsToggle = document.getElementById("chartsToggle");
		chartsToggle.classList.toggle("open");
		chartsToggle.classList.toggle("closed");
	});

	window.onload = updateCSS;
	window.onresize = onResize;
</script>

</body>
</html>