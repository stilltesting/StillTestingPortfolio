<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="stylesheet" type="text/css" href="./style/style.css">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,500,0,0" />

	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

	<style>
	    :root {
	      --chapter-scale: 3;
	      --subsection-scale: 2;
	      --root-font-size: 18px;
	    }

	    h2.chapter {
	    	font-size: var(--chapter-scale);
	    }

	    h3.subsection {
	    	font-size: var(--subsection-scale);
	    }

	    body {
	    	font-size: var(--root-font-size);
	    }
	</style>

	<title>Fluid Typography Structure Widget</title>
</head>
<body>
<div id="buttons">
	<button id="parametersToggle" class="open">
		<span class="material-symbols-outlined">tune</span>
	</button>
	<button id="chartsToggle" class="closed">
		<span class="material-symbols-outlined">monitoring</span>
	</button>
</div>

<div id="controls">
	<div id="parameters" class="show">
		<h2 class="UI-text">Parameters</h2>
		<div class="block">
			<h3 class="UI-text">Font Size Scaling</h3>

			<label for="minRes">Minimal resolution [px]:</label><br>
			<input type="number" id="minRes" name="minRes" value="480" step="120" onchange="updateCSS()"><br>

			<label for="maxRes">Maximal resolution [px]:</label><br>
			<input type="number" id="maxRes" name="maxRes" value="1920" step="120" onchange="updateCSS()"><br>

			<label for="minFontSize">Minimal font size [px]:</label><br>
			<input type="number" id="minFontSize" name="minFontSize" value="18" step="1" onchange="updateCSS()"><br>

			<label for="maxFontSize">Maximal font size [px]:</label><br>
			<input type="number" id="maxFontSize" name="maxFontSize" value="22" step="1" onchange="updateCSS()"><br>
		</div>

		<div class="block">
			<h3 class="UI-text">Leading</h3>
			
			<label for="minLeading">Minimal leading [em]:</label><br>
			<input type="number" id="minLeading" name="minLeading" value="1.4" step="0.1" onchange="updateCSS()"><br>

			<label for="maxLeading">Maximal leading [em]:</label><br>
			<input type="number" id="maxLeading" name="maxLeading" value="1.8" step="0.1" onchange="updateCSS()"><br>
		</div>

		<div class="block">
			<h3 class="UI-text">Scaling Hierarchy</h3>
					
			<label for="minChapterScale">H1 Minimal Scale Factor:</label><br>
			<input type="number" id="minChapterScale" name="minChapterScale" value="3" step="0.5" onchange="updateCSS()"><br>

			<label for="maxChapterScale">H1 Maximal Scale Factor:</label><br>
			<input type="number" id="maxChapterScale" name="maxChapterScale" value="5" step="0.5" onchange="updateCSS()"><br>

			<label for="minSubsectionScale">H2 Minimal Scale Factor:</label><br>
			<input type="number" id="minSubsectionScale" name="minSubsectionScale" value="1.2" step="0.1" onchange="updateCSS()"><br>

			<label for="maxSubsectionScale">H2 Maximal Scale Factor:</label><br>
			<input type="number" id="maxSubsectionScale" name="maxSubsectionScale" value="1.5" step="0.1" onchange="updateCSS()"><br>
		</div>

		<div style="clear:both"></div>

		<button onclick="updateCSS()" id="updateCSS">Update CSS</button>

	</div>

	<div id="charts" class="hide">
		<h2 class="UI-text">Charts</h2>
		<h3 class="UI-text">Font Size Progression</h3>
		<canvas id="fontSizeChart"></canvas>

		<h3 class="UI-text">Leading Progression</h3>
		<canvas id="leadingChart"></canvas>

		<h3 class="UI-text">Hierarchy Relative Progression</h3>
		<canvas id="hierarchyChart"></canvas>
	</div>
</div>

<div id="contentWrapper" lang="cs">
	<div id="textBox">
		<h2 class="chapter">Úvod</h2>
		
		<p>
			Kniha má v&nbsp;sociokulturním prostoru výsadní postavení jako intelektuální, estetický i&nbsp;společenský artefakt. S&nbsp;konceptem knihy je neoddělitelně spjata značná část historie a&nbsp;vývoje typografie a&nbsp;grafického designu. Nástup digitalizace a&nbsp;rozšíření výpočetních technologií je spjatý též s&nbsp;rozšířením čtení v&nbsp;elektronické podobě a&nbsp;vznikem takzvané elektronické knihy (též e-knihy). Proces jejího utváření však stále není dovršen, ať už z&nbsp;hlediska společenského a&nbsp;kulturního vnímání či grafického designu a&nbsp;typografie. Elektronická kniha je tak stále vnímána jako jakási podružná alternativa ke knize tištěné. Design elektronických knih je zpravidla chudý až neexistující, sklouzává k&nbsp;uniformitě a&nbsp;individuální tvář e-knihy se omezuje pouze na pomyslnou obálku. Čestné výjimky ve formě autorských či uměleckých e-knih, které tvoří rovnocennou alternativu tištěných knih a&nbsp;působí jako svébytné artefakty, často stojí mimo hlavní proud zájmu čtenářů. Jejich výtvarná pojetí jsou odvážná, experimentální a&nbsp;nezařaditelná do běžné produkce, podobně jako různá bibliofilská vydání, jaká známe z&nbsp;prostředí tištěných knih. Spojujícím prvkem takto vypravených knih je paradoxně jejich diverzita&nbsp;— oproti běžné produkci využívají celou škálu individuálních výtvarných i&nbsp;typografických přístupů, které prakticky nelze uplatnit v&nbsp;širším kontextu. Na jedné straně tedy máme grafickou úpravu takřka neznatelnou, na druhé straně nesmírně bohatou až přebujelou. Pomyslná střední cesta běžné knižní produkce v&nbsp;digitálním prostoru takřka neexistuje.
		</p>

		<p>
			Kniha je velmi komplexní pojem, se kterým je spjato obrovské množství otázek spojených s&nbsp;její kulturní, společenskou i&nbsp;estetickou funkcí a&nbsp;s&nbsp;technologickou stránkou její produkce, její materialitou, její uživatelskou zkušeností a&nbsp;mnoha dalšími aspekty. Jako kterýkoliv jiný komplexní pojem tvoří i&nbsp;kniha síť vzájemně provázaných vhledů. Proto, je-li řeč o&nbsp;knižním designu, grafické úpravě a&nbsp;typografii, nelze opomenout ani tato další hlediska. Spektrum použité a&nbsp;studované literatury je tak odpovídajícím způsobem široké a&nbsp;pokrývá značnou škálu oborů, které se knihou zabývají z&nbsp;různých úhlů pohledu.
		</p>

		<h3 class="subsection">Nové jevy, staré pojmy</h3>

		<p>
			Benjamin Bratton (2016) ve své knize a&nbsp;zároveň manifestu stejnojmenného programu institutu Strelka The New Normal tvrdí, že k&nbsp;popisu nových jevů často jsou často používány kombinace starých, zaužívaných pojmů. Toto označování nového starým pak podle Brattona vede k&nbsp;určitému omezení rozhledu a&nbsp;umělému limitování potenciálu nových technologií. Jako příklad uvádí v&nbsp;prvopočátcích vynálezu moderních automobilů často užívaný pojem kočár bez koní (horseless carriage), který při návrhu nových vozidel naváděl k&nbsp;používání designového jazyka spjatého s&nbsp;klasickým koňským spřežením, a&nbsp;to včetně připodobnění sedadla řidiče posedu pro kočího (Bratton 2016)&nbsp;— podobně mluví též Drucker (2003). Emancipačním momentem vynálezu se stalo až opuštění této představy, přizpůsobení vozidel potřebám řidiče a&nbsp;cestujících&nbsp;— vstup designu&nbsp;— a&nbsp;vznik pojmu automobil. Podobnou situaci je dnes stále možné sledovat na poli elektronických knih. Ty&nbsp;se staly natolik všudypřítomnými a&nbsp;dosáhly takové sociokulturní penetrace, že s naprostou samozřejmostí vstupují do našich životů skrze displeje našich telefonů a počítačů. Málokoho tak napadne zpochybňovat jejich formu, styl i&nbsp;charakter. Staly se jakýmsi substitutem té pravé tištěné knihy s&nbsp;obecně přijímanými, nezpochybňovanými a&nbsp;v&nbsp;důsledku takřka neviditelnými nedostatky. Elektronické knihy jsou tak stále vztahovány a kontrastovány se svým tištěným předobrazem a&nbsp;stávají se v&nbsp;podstatě jeho pokřiveným digitálním zrcadlem, jakýmsi nedokonalým odrazem (Velagić 2014; Kovač 2019). V&nbsp;souladu s&nbsp;tím je možné pozorovat jakousi efemérnost digitální typografie (Bath 2012),&nbsp;ta se pak stává pouhým utilitárním nástrojem k&nbsp;předání informace. Tento pocit efemérnosti se tranzitivně přenáší na celou elektronickou knihu&nbsp;— po přečtení se ztrácí kdesi v&nbsp;digitálním prostoru, kde&nbsp;— dále neviditelná&nbsp;— neplní, ani nemůže plnit svou reprezentační a&nbsp;společenskou funkci (Gruningová 2018).
		</p>
	</div>
</div>

<script>
	var textBox = document.getElementById("textBox");
	var minRes = document.getElementById("minRes").value;
    var maxRes = document.getElementById("maxRes").value;
    var minFontSize = document.getElementById("minFontSize").value;
    var maxFontSize = document.getElementById("maxFontSize").value;
	
	var minLineHeight = document.getElementById("minLeading").value;
    var maxLineHeight = document.getElementById("maxLeading").value;

    var minChapterScale = document.getElementById("minChapterScale").value;
    var maxChapterScale = document.getElementById("maxChapterScale").value;
    var minSubsectionScale = document.getElementById("minSubsectionScale").value;
    var maxSubsectionScale = document.getElementById("maxSubsectionScale").value;

    var currentTextFontSize = parseFloat(getComputedStyle(textBox).getPropertyValue('font-size'));
    var viewportWidth = document.documentElement.clientWidth;

    var currentLeading = parseFloat(getComputedStyle(textBox).getPropertyValue("line-height")) / currentTextFontSize;
    var maxWidth = parseFloat(getComputedStyle(textBox).getPropertyValue('max-width'));
    
    var chapterFontSize;
    var subsectionFontSize;




	function onResize() {
		updateLineHeight();
		updateHierarchyScaling();
		updateCharts()
	}

    function updateCSS() {
    	updateRootFontSize();
		updateFontScaling();
    	updateLineHeight();
    	updateHierarchyScaling();
    	updateCharts();
    }

    function updateRootFontSize() {
    	minFontSize = document.getElementById("minFontSize").value;
    	document.documentElement.style.setProperty('--root-font-size', minFontSize);
    }

    function updateFontScaling() {
    	// Reading the inputs
    	minRes = document.getElementById("minRes").value;
    	maxRes = document.getElementById("maxRes").value;
    	minFontSize = document.getElementById("minFontSize").value;
    	maxFontSize = document.getElementById("maxFontSize").value;

    	// Computing fluid font scaling
    	var deltaRes = maxRes - minRes;
    	var deltaFontSize = maxFontSize - minFontSize;

    	var fontSizeExpression = "calc(" + minFontSize + "px + (" + deltaFontSize + " * ((100vw - " + minRes + "px) / " + deltaRes + ")))";

      	// Applying the styles
      	textBox.style.fontSize = "clamp(" + minFontSize + "px, " + fontSizeExpression + ", " + maxFontSize + "px)";
    }

    function updateLineHeight() {
    	minLineHeight = document.getElementById("minLeading").value;
    	maxLineHeight = document.getElementById("maxLeading").value;

    	// Getting required variables
    	var width = parseFloat(getComputedStyle(textBox).getPropertyValue('width'));
    	var maxWidth = parseFloat(getComputedStyle(textBox).getPropertyValue('max-width'));

		// Computing fluid leading
		var deltaLineHeight = maxLineHeight - minLineHeight;

		var lineHeight = maxLineHeight - deltaLineHeight * (maxWidth - width) / (maxWidth - minRes);

		var lineHeightExpression = "clamp(" + minLineHeight + "em, " + lineHeight + "em," + maxLineHeight + "em)";

		textBox.style.lineHeight = lineHeightExpression;
    }

    function updateHierarchyScaling() {
		minChapterScale = document.getElementById("minChapterScale").value;
		maxChapterScale = document.getElementById("maxChapterScale").value;
		minSubsectionScale = document.getElementById("minSubsectionScale").value;
		maxSubsectionScale = document.getElementById("maxSubsectionScale").value;

    	var deltaChapterScale = maxChapterScale - minChapterScale;
    	var deltaSubsectionScale = maxSubsectionScale - minSubsectionScale;
    	var deltaTextFontSize = maxFontSize - minFontSize;
    	currentTextFontSize = parseFloat(getComputedStyle(textBox).getPropertyValue('font-size'));

    	var fontSizeFactor = (maxFontSize - currentTextFontSize) / deltaTextFontSize

    	chapterFontSize = Number(maxChapterScale) - deltaChapterScale * fontSizeFactor;
    	subsectionFontSize = Number(maxSubsectionScale) - deltaSubsectionScale * fontSizeFactor;

    	var chapterFontSizeExpression = "clamp(" + minChapterScale + "em, " + chapterFontSize + "em," + maxChapterScale + "em)";
    	var subsectionFontSizeExpression = "clamp(" + minSubsectionScale + "em, " + subsectionFontSize + "em," + maxSubsectionScale + "em)";

    	document.documentElement.style.setProperty('--chapter-scale', chapterFontSizeExpression);
    	document.documentElement.style.setProperty('--subsection-scale', subsectionFontSizeExpression);
    }

    //Charts config defaults
    Chart.defaults.font.family = "Space Mono";
    Chart.defaults.plugins.legend.display = false;
    Chart.defaults.borderColor = 'rgba(0, 0, 0, 0.3)';
    Chart.defaults.color = '#000';

	var fontSizeChart = new Chart(document.getElementById('fontSizeChart'), {
		type: 'line',
		data: {
			label: ["Font Size Progression"],
			datasets: [{
				data: [{x: 0, y: minFontSize}, {x: minRes, y: minFontSize}, {x: maxRes, y: maxFontSize}, {x: Number(maxRes) + 480, y: maxFontSize}],
				order: 2,
				pointBackgroundColor: "blue",
				pointBorderWidth: 0,
				borderColor: "blue",
				borderWidth: 2
			},
			{
				data: [{x: viewportWidth, y: currentTextFontSize}],
				order: 1,
				pointBackgroundColor: "black",
				borderColor: "black"
			}]
		},
		options: {
			scales: {
				y: {
					beginAtZero: true
				}, 
				x: {
					type: 'linear',
					bounds: "data",
					ticks: {
                   		maxRotation: 35,
                   		minRotation: 35
                	},
					afterBuildTicks: axis => axis.ticks = [0, Number(minRes), Number(maxRes), Math.max(Number(maxRes) + 480, viewportWidth)].map(v => ({ value: v }))
        		}
			},
			animation: {
				duration: 100
			},
			aspectRatio: 1.5
		}
	});

	var leadingChart = new Chart(document.getElementById('leadingChart'), {
		type: 'line',
		data: {
			label: ["Leading Progression"],
			datasets: [{
				data: [{x: 0, y: minLineHeight}, {x: Number(minRes), y: minLineHeight}, {x: Number(maxWidth), y: maxLineHeight}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxLineHeight}],
				order: 2,
				pointBackgroundColor: "blue",
				pointBorderWidth: 0,
				borderColor: "blue",
				borderWidth: 2
			},
			{
				data: [{x: viewportWidth, y: currentLeading}],
				order: 1,
				pointBackgroundColor: "black",
				borderColor: "black"
			}]
		},
		options: {
			scales: {
				y: {
					beginAtZero: true
				}, 
				x: {
					type: 'linear',
					bounds: "data",
					ticks: {
                   		maxRotation: 35,
                   		minRotation: 35
                	},
					afterBuildTicks: axis => axis.ticks = [0, Number(minRes), Number(maxWidth), Number(maxRes), Math.max(Number(maxRes) + 480, viewportWidth)].map(v => ({ value: v })),
        		}
			},
			animation: {
				duration: 100
			},
			aspectRatio: 1.5
		}
	});

	var hierarchyChart = new Chart(document.getElementById('hierarchyChart'), {
		type: 'line',
		data: {
			label: ["Hierarchy Relative Progression"],
			datasets: [{
				data: [{x: 0, y: minChapterScale}, {x: minRes, y: minChapterScale}, {x: maxRes, y: maxChapterScale}, {x: Number(maxRes) + 480, y: maxChapterScale}],
				order: 2,
				pointBackgroundColor: "blue",
				pointBorderWidth: 0,
				borderColor: "blue",
				borderWidth: 2
			},
			{
				data: [{x: 0, y: minSubsectionScale}, {x: minRes, y: minSubsectionScale}, {x: maxRes, y: maxSubsectionScale}, {x: Number(maxRes) + 480, y: maxSubsectionScale}],
				order: 2,
				pointBackgroundColor: "BlueViolet ",
				pointBorderWidth: 0,
				borderColor: "BlueViolet",
				borderWidth: 2
			},
			{
				data: [{x: viewportWidth, y: chapterFontSize}],
				order: 1,
				pointBackgroundColor: "black",
				borderColor: "black"
			},
			{
				data: [{x: viewportWidth, y: subsectionFontSize}],
				order: 1,
				pointBackgroundColor: "black",
				borderColor: "black"
			}]
		},
		options: {
			scales: {
				y: {
					beginAtZero: true
				}, 
				x: {
					type: 'linear',
					bounds: "data",
					ticks: {
                   		maxRotation: 35,
                   		minRotation: 35
                	},
					afterBuildTicks: axis => axis.ticks = [0, Number(minRes), Number(maxRes), Math.max(Number(maxRes) + 480, viewportWidth)].map(v => ({ value: v }))
        		}
			},
			animation: {
				duration: 100
			},
			aspectRatio: 1.5
		}
	});

	function updateCharts() {
		currentTextFontSize = parseFloat(getComputedStyle(textBox).getPropertyValue('font-size'));
	    viewportWidth = document.documentElement.clientWidth;
	    currentLeading = parseFloat(getComputedStyle(textBox).getPropertyValue("line-height")) / currentTextFontSize;
	    maxWidth = parseFloat(getComputedStyle(textBox).getPropertyValue('max-width'));
	    console.log(maxWidth);

    	fontSizeChart.data.datasets[0].data = [{x: 0, y: minFontSize}, {x: minRes, y: minFontSize}, {x: maxRes, y: maxFontSize}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxFontSize}];
    	fontSizeChart.data.datasets[1].data = [{x: viewportWidth, y: currentTextFontSize}];
    	fontSizeChart.update();

    	leadingChart.data.datasets[0].data = [{x: 0, y: minLineHeight}, {x: Number(minRes), y: minLineHeight}, {x: Number(maxWidth), y: maxLineHeight}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxLineHeight}];
    	leadingChart.data.datasets[1].data = [{x: viewportWidth, y: currentLeading}];
    	leadingChart.update();

    	hierarchyChart.data.datasets[0].data = [{x: 0, y: minChapterScale}, {x: minRes, y: minChapterScale}, {x: maxRes, y: maxChapterScale}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxChapterScale}];
    	hierarchyChart.data.datasets[1].data = [{x: 0, y: minSubsectionScale}, {x: minRes, y: minSubsectionScale}, {x: maxRes, y: maxSubsectionScale}, {x: Math.max(Number(maxRes) + 480, viewportWidth), y: maxSubsectionScale}];
    	hierarchyChart.data.datasets[2].data = [{x: viewportWidth, y: chapterFontSize}];
    	hierarchyChart.data.datasets[3].data = [{x: viewportWidth, y: subsectionFontSize}];
    	hierarchyChart.update();
    };


    document.getElementById("parametersToggle").addEventListener("click", function() {
  		var controls = document.getElementById("controls");
		controls.classList.toggle("show");
		controls.classList.toggle("hide");
		var parametersToggle = document.getElementById("parametersToggle");
		parametersToggle.classList.toggle("open");
		parametersToggle.classList.toggle("closed");
	});

	document.getElementById("chartsToggle").addEventListener("click", function() {
		var charts = document.getElementById("charts");
		charts.classList.toggle("show");
		charts.classList.toggle("hide");
		var chartsToggle = document.getElementById("chartsToggle");
		chartsToggle.classList.toggle("open");
		chartsToggle.classList.toggle("closed");
	});

	window.onload = updateCSS;
	window.onresize = onResize;
</script>

</body>
</html>